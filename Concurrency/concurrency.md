
concurrency 

1. thread - 실행 흐름을 의미

프로그램이 실행되는 과정을 보면 

프로그램(명령어 다발) 로드 > 메모리로 올라간다 > cpu에서 실행한다.

cpu는 명령어 (연산자, 피연산자)를 읽어 실행

엔트리 포인트부터.. (go 에서는 main())

여기서부터 한 줄 읽어서 cpu가 실행, ip point를 증가 > 실행 > ...반복

하나의 실행 주체(cpu)가 ip point에 있는 코드를 실행하는 실행 흐름이 스레드이다.

//

멀티 스레드

실행 흐름이 여러개가 된다.

코어가 하나라도 가능함.

코어가 스레드를 빠르게 교체하는 것..

스레드마다 ip point를 가지고 있으므로..

그것만 기억하고 번갈아 가며 실행하면

우리에겐 마치 프로그램이 동시에 실행되는것처럼 보인다.

(cpu는 가만 있고, 스레드는 os가 바꾸는 것)

//

멀티 스레딩 원리

cpu는 계산만 한다. 스레드고 뭐고 모은다.

os가 실행할 코드를 관리한다.

//

context switching

스레드 전환에는 성능상 비용이 발생한다.

이걸 컨텍스트 스위칭이라고 한다.

stack memory : 스레드 별로 따로 있음
// 스레드가 바뀌면 이런 것들도 바꿔줘야 함

heap memory : 전체 스레드가 공유

//

만약 스레드 수 = 코어 갯수가 되면?

context switching이 발생하지 않는다.

cf) 멀티 프로세스 vs 멀티 스레드

멀티 프로세스 :

프로세스 : 프로그램을 실행하면 메모리에 로드 > 실행

계산기를 실행

하나 더 실행하면?

또 다른 메로리에 로드해 실행

> 실행 인스턴스가 2개 (프로세스가 2개) w/ program 1개

실행 주체가 서로 다르다. 프로그램은 같은데..

//

멀티 스레드 :

하나의 프로세스 안에서도 실행 흐름이 여러 개 있다.

하나의 프로그램 안에서 스레드가 여러 개..

여기선 멀티 스레드를 얘기하고 있다.

//

go routine

go에서 만든 경량 스레드

메인 함수도 고 루틴을 가지고 있다. 이 또한 실행 흐름의 하나이기 때문에..

기본적으로 모든 고프로그램은 한 개의 고루틴 (= 하나의 스레드을 가지고 있다. (메인)

//

ex.go

package main
import (
    "fmt"
    "time"
)

func PrintHangul() {
    hanguls := []rune { '가', '나', '다', '리'}

    for _, v := range hanguls {
        time.Sleep(300 * time.Millisecond)
        fmt.printf("%c ", v)
    }
}

func PrintNumbers() {
    for i :=1; i <=5; i++ {
        time.Sleep(400 * time.millisecond)
        fmt.Printf("%d", i)
    }
}


func main() {
    go PrintHangul()
    go PrintNumbers()

    time.Sleep(3 * time.Second)
}

이러면 총 3개의 고루틴이 생성된다.

메인 루틴, printhangul, printnumber

여기서 만약 메인 함수가 3초를 기다리지 않으면?

메인 함수가 종료되면 프로그램이 종료되기 때문에

다른 루틴들이 완료되기 전에 끊겨버림

근데 예상 시간을 모르면 어떻게 하냐?

서브 루틴이 끝날때까지 대기하는 방법이 있다.

sync package에 WaitGroup 함수가 있다.

var wg sync.WaitGroup

wg.Add(3) // 숫자 설정
wg.Done() // 작업이 완료될 때마다 호출
wg.Wait() // 작업이 완ㄹ될 때까지 대기

24.2.go 참고

//

그래서 고루틴이 뭐가 좋냐?

고루틴은 스레드가 아님.

고루틴이 스레드를 이용한다.

코어 - os 스레드를 매칭시켜서 고정시킴

> 컨텍스트 스위칭 비용이 발생하지 않는다.

코어 갯수가 스레드 갯수보다 늘어나지않고, os단에서 컨텍스트 스위칭이 안 일어난다.

go 루틴의 컨텍스트 스위칭이 일어나는데 이는 os의 그것에 비해 경량이다.

//

concurrency (동시성)

각 고루틴들이 각 코어들과 매치되서 따로 진행이 되느데

서로 다른 고루틴이 힙 메모리의 같은 메모리에 동시에 접근 할 떄 동시성 문제가 발생한다.

24.3 ~ 24.5 참조

//

또 다른 자원 관리 기법 (무텍스 말고)

1. 영역을 나누는 방법

2. 역할을 나누는 방법


//

24.6 영역을 나누는 방법

24.6.go 참조

역할을 나누는 방법은 채널.. 다음 시간에..